# AI 기반 Greenfield 프로젝트 개발 계획 (단독 개발자, PlatformIO 환경)

## 1. 서론

본 문서는 제가 (Gemini AI) DS18B20 온도 센서 프로젝트와 같은 임베디드 시스템 개발 프로젝트를 **완전히 새로운 시작(Greenfield)**으로 가정하고, **단독 개발자**가 **AI의 도움**을 받아 **PlatformIO 환경**에서 프로젝트를 개발, 관리, 문서화하는 방법에 대한 상세한 계획을 제시합니다. 목표는 초기부터 모듈성, 테스트 용이성, 유지보수성, 확장성을 극대화하고, AI의 역량을 최대한 활용하여 효율적이고 견고한 개발 프로세스를 구축하는 것입니다.

## 2. 프로젝트 초기 설정 및 구조화

### 2.1. PlatformIO 프로젝트 초기화
-   **AI의 역할:** PlatformIO CLI 명령어를 사용하여 프로젝트를 초기화하고, 대상 보드(예: `esp32dev`, `uno`)를 지정합니다.
    ```bash
    pio project init --board <your_board_id>
    ```
-   **초기 디렉토리 구조:** PlatformIO가 생성하는 기본 구조를 따르되, 명확한 역할 분담을 위해 다음과 같이 확장합니다.
    ```
    /
    ├── .pio/
    ├── .vscode/
    ├── lib/                # PlatformIO 라이브러리 관리 (외부 라이브러리)
    ├── src/                # 모든 애플리케이션 소스 코드
    │   ├── main.cpp        # 메인 진입점 (setup(), loop() 포함)
    │   ├── domain/         # 핵심 비즈니스 로직 (하드웨어 독립적)
    │   ├── application/    # 유스케이스 구현 (도메인 계층 사용)
    │   └── infrastructure/ # 하드웨어 인터페이스, 통신 등 구체적 구현
    ├── test/               # 유닛 및 통합 테스트 코드
    │   ├── unit/           # PC 기반 유닛 테스트
    │   └── integration/    # 하드웨어 기반 통합 테스트
    ├── docs/               # 프로젝트 문서 (설계, 분석, 사용자 가이드 등)
    ├── .gitignore          # 버전 관리 제외 파일 설정
    ├── platformio.ini      # PlatformIO 설정 파일
    └── README.md           # 프로젝트 개요
    ```

### 2.2. `platformio.ini` 설정
-   **AI의 역할:** 초기 `platformio.ini` 파일을 설정하여 보드 타입, 프레임워크, 빌드 옵션, 테스트 환경 등을 정의합니다.
    -   **테스트 환경 분리:** `test_build_src = yes` 옵션을 사용하여 테스트 빌드 시 `src` 폴더의 코드를 포함하도록 설정하고, `test_ignore`를 통해 특정 파일을 제외합니다.
    -   **라이브러리 의존성:** `lib_deps`를 사용하여 필요한 라이브러리(예: `OneWire`, `DallasTemperature`)를 명시적으로 관리합니다.

## 3. 개발 워크플로우 (AI 중심)

### 3.1. 테스트 주도 개발 (TDD) 원칙 적용
-   **AI의 역할:** 모든 새로운 기능 개발은 테스트 케이스 작성에서 시작합니다.
    1.  **실패하는 테스트 작성:** AI에게 구현할 기능의 요구사항을 설명하고, 해당 기능을 검증할 유닛 테스트 코드를 작성하도록 지시합니다. 이 테스트는 처음에는 실패해야 합니다.
    2.  **최소한의 코드 작성:** AI에게 테스트를 통과시킬 수 있는 최소한의 애플리케이션 코드를 작성하도록 지시합니다.
    3.  **테스트 통과 확인:** AI가 PlatformIO의 테스트 기능을 사용하여 테스트를 실행하고 통과 여부를 확인합니다.
    4.  **리팩토링:** AI에게 작성된 코드를 클린 아키텍처 원칙, 코딩 표준, 디자인 패턴에 따라 리팩토링하도록 지시합니다. 이 과정에서도 테스트는 계속 통과해야 합니다.
-   **반복:** 이 과정을 반복하여 점진적으로 기능을 확장하고 코드를 개선합니다.

### 3.2. 클린 아키텍처 및 의존성 역전 원칙 (DIP) 초기부터 적용
-   **AI의 역할:** 프로젝트 초기부터 `domain`, `application`, `infrastructure` 계층을 명확히 분리하고, 각 계층 간의 의존성을 추상화(인터페이스)를 통해 관리하도록 코드를 생성합니다.
-   **예시:**
    -   `domain/temperature_sensor.h`: `ITemperatureSensor` 인터페이스 정의 (하드웨어 독립적)
    -   `infrastructure/ds18b20_hardware.h/.cpp`: `ITemperatureSensor` 인터페이스를 구현하는 실제 DS18B20 하드웨어 제어 클래스
    -   `application/temperature_service.h/.cpp`: `ITemperatureSensor` 인터페이스를 주입받아 온도 측정 로직을 수행하는 서비스 클래스
    -   `src/main.cpp`: `infrastructure` 계층의 구체적인 객체를 생성하여 `application` 계층에 주입하고 시스템을 초기화합니다.

### 3.3. Mocking 및 의존성 주입 (DI) 활용
-   **AI의 역할:** 유닛 테스트 시 하드웨어 의존성을 제거하기 위해 Mocking 프레임워크(예: Google Mock 또는 수동 Mock)를 사용하여 인터페이스에 대한 Mock 객체를 생성하고, 이를 테스트 대상 클래스에 주입하도록 코드를 작성합니다.
-   **이점:** AI가 실제 하드웨어 없이도 모든 유닛 테스트를 PC에서 빠르게 실행하고 검증할 수 있어 개발 속도가 비약적으로 향상됩니다.

## 4. 관리 워크플로우 (단독 개발자, AI 지원)

### 4.1. 버전 관리 (GitHub Flow)
-   **AI의 역할:** 모든 코드 변경은 새로운 브랜치에서 시작하고, 작업 완료 후 Pull Request를 생성하여 `main` 브랜치로 병합합니다.
    -   `main` 브랜치는 항상 배포 가능한 상태를 유지합니다.
    -   AI에게 `git status`, `git add`, `git commit`, `git push`, `git checkout -b`, `git pull-request` 등의 명령어를 지시하여 버전 관리를 수행합니다.
-   **단독 개발자 이점:** 복잡한 Git Flow 대신 단순한 GitHub Flow를 사용하여 관리 오버헤드를 최소화합니다.

### 4.2. 이슈 트래킹 (GitHub Issues)
-   **AI의 역할:** 기능 요청, 버그, 개선 사항 등을 GitHub Issues에 기록하고 관리합니다.
    -   AI에게 특정 작업을 이슈로 등록하도록 지시하고, 작업 완료 시 이슈를 닫도록 합니다.
    -   이슈를 통해 개발 진행 상황을 추적하고 우선순위를 관리합니다.

### 4.3. 지속적 통합/지속적 배포 (CI/CD) - GitHub Actions
-   **AI의 역할:** 프로젝트 초기부터 `.github/workflows/main.yml` 파일을 설정하여 CI/CD 파이프라인을 구축합니다.
    -   **자동 빌드:** 코드 푸시 또는 Pull Request 발생 시 PlatformIO를 사용하여 프로젝트를 자동으로 빌드합니다.
    -   **자동 유닛 테스트:** 빌드 성공 시 PlatformIO의 유닛 테스트를 자동으로 실행하고 결과를 보고합니다.
    -   **정적 분석:** `cppcheck`, `clang-tidy`와 같은 정적 분석 도구를 통합하여 코드 품질을 자동으로 검사합니다.
    -   **메모리 사용량 보고:** 빌드된 펌웨어의 메모리 사용량 변화를 추적하고 보고서를 생성합니다.
-   **이점:** AI가 코드를 변경할 때마다 자동으로 품질 검증이 이루어져, 단독 개발 환경에서 발생할 수 있는 실수를 조기에 발견하고 수정할 수 있습니다.

## 5. 문서화 전략 (AI 지원)

### 5.1. Living Documentation
-   **AI의 역할:** 코드가 변경될 때마다 관련 문서도 함께 업데이트되도록 합니다. AI에게 코드 변경 후 관련 문서 섹션을 업데이트하도록 지시합니다.
-   **README.md:** 프로젝트 개요, 빌드/실행 방법, 주요 기능, 기여 방법 등을 명확히 기술합니다.

### 5.2. 설계 문서 (`docs/design/`)
-   **AI의 역할:** 주요 아키텍처 결정, 모듈 간 인터페이스, 복잡한 알고리즘 등에 대한 문서를 Markdown 형식으로 작성합니다.
    -   AI에게 특정 모듈의 설계 의도를 설명하고, 이를 문서화하도록 요청합니다.
    -   클래스 다이어그램, 시퀀스 다이어그램 등은 Mermaid 문법을 사용하여 텍스트 기반으로 작성하여 버전 관리에 용이하게 합니다.

### 5.3. API 문서 (Doxygen 또는 유사 도구)
-   **AI의 역할:** 코드 내 주석을 기반으로 API 문서를 자동으로 생성하도록 설정합니다.
    -   AI에게 함수, 클래스, 변수 등에 대한 Doxygen 스타일 주석을 작성하도록 지시합니다.
    -   CI/CD 파이프라인에 문서 자동 생성 단계를 추가하여 최신 API 문서를 유지합니다.

### 5.4. 변경 로그 (`CHANGELOG.md`)
-   **AI의 역할:** 모든 주요 변경 사항(기능 추가, 버그 수정, 리팩토링)을 기록합니다. AI에게 커밋 메시지를 기반으로 변경 로그를 업데이트하도록 지시합니다.

## 6. 분석 및 품질 보증 (AI 지원)

### 6.1. 코드 리뷰 (AI 자가 리뷰)
-   **AI의 역할:** Pull Request 생성 시 AI가 스스로 코드 리뷰를 수행합니다.
    -   코딩 표준 준수 여부, 잠재적 버그, 설계 원칙 위배 여부 등을 자동으로 검토하고 피드백을 제공합니다.
    -   이는 단독 개발 환경에서 동료 리뷰의 부재를 보완하는 중요한 역할을 합니다.

### 6.2. 정적 분석
-   **AI의 역할:** CI/CD 파이프라인에 통합된 정적 분석 도구(cppcheck, clang-tidy)의 결과를 분석하고, AI에게 발견된 문제점을 수정하도록 지시합니다.

### 6.3. 메모리 및 성능 분석
-   **AI의 역할:** PlatformIO의 `.map` 파일 분석 기능을 활용하여 메모리 사용량을 정기적으로 모니터링하고, AI에게 메모리 최적화 방안을 제안하도록 요청합니다.
-   필요시 AI에게 특정 코드 블록의 실행 시간을 측정하는 프로파일링 코드를 삽입하도록 지시하여 성능 병목을 식별합니다.

## 7. 결론

이 계획은 AI의 강력한 코드 생성, 분석, 테스트 자동화 능력을 최대한 활용하여 단독 개발자가 고품질의 임베디드 소프트웨어를 효율적으로 개발할 수 있는 프레임워크를 제공합니다. 초기부터 견고한 아키텍처와 자동화된 프로세스를 구축함으로써, 개발자는 핵심 기능 구현에 집중하고 AI는 반복적이고 검증 가능한 작업을 수행하여 개발 생산성과 소프트웨어 품질을 동시에 향상시킬 수 있습니다.
