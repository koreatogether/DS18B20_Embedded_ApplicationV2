# 저장소 구조 분석 및 개선 방향 보고서

## 1. 개요
본 문서는 현재 프로젝트의 구조, 코드 스타일, 테스트 방식 등을 분석하고, 장기적인 유지보수성, 확장성, 안정성 향상을 위한 개선 방향을 제안하는 것을 목적으로 한다. 제안의 핵심은 다음과 같다.

-   **객체 지향 프로그래밍(OOP)의 체계적 도입**
-   **독립적이고 신뢰성 있는 유닛 테스트 환경 구축**
-   **소스코드와 테스트 코드의 명확한 분리**
-   **표준화된 디렉토리 구조 도입**

## 2. 현황 분석

### 2.1. 디렉토리 구조
현재 소스코드(.cpp, .h), 테스트 코드, 설정 파일, 문서 등 대부분의 파일이 루트 디렉토리에 위치하고 있다.

-   **장점:** 소규모 프로젝트에서는 파일 접근이 빠르고 구조가 단순해 보일 수 있다.
-   **단점:**
    -   프로젝트 규모가 커질수록 파일의 역할과 목적을 파악하기 어렵다.
    -   빌드 시스템(컴파일)과 테스트 시스템이 강하게 결합될 가능성이 높다.
    -   새로운 개발자가 프로젝트 구조를 이해하는 데 시간이 오래 걸린다.

### 2.2. 코드 구조 및 OOP 적용 수준
`App`, `Communicator`, `DataProcessor`, `DS18B20_Sensor` 등 클래스 기반으로 코드가 작성되어 있어 OOP의 기본 개념은 적용되어 있다.

-   **장점:** 기능별로 코드가 분리되려는 시도가 보인다.
-   **단점:**
    -   클래스 간의 의존성이 높아 보인다. 예를 들어, `App` 클래스가 다른 구체적인 클래스(Concrete Class)에 직접 의존하고 있을 가능성이 크다.
    -   이로 인해 특정 기능을 수정하거나 교체하기 어렵고, 유닛 테스트 시 Mock 객체 활용이 제한될 수 있다.

### 2.3. 유닛 테스트 현황
`test/` 디렉토리 내에 Unity 테스트 프레임워크를 사용한 테스트 코드가 존재하며, 시나리오 기반의 테스트가 작성되어 있다.

-   **장점:**
    -   이미 테스트 프레임워크가 도입되어 있고, 테스트 작성 문화가 존재한다.
    -   `MockCommunicator.h` 등의 Mock 객체를 사용하려는 시도가 있어 의존성 분리의 필요성을 인지하고 있다.
-   **단점:**
    -   테스트 코드와 실제 컴파일 코드가 동일한 소스 파일을 공유하며 빌드될 가능성이 높아, 의존성 분리가 완벽하지 않다.
    -   이로 인해 테스트 빌드 시간이 길어지고, 테스트 환경이 실제 하드웨어/Arduino 환경에 종속될 수 있다.
    -   개별 클래스나 함수 단위의 순수한 유닛 테스트보다는 통합 테스트에 가까운 형태가 많을 수 있다.

## 3. 개선 방향 제안

### 3.1. 추천 디렉토리 구조
프로젝트의 가독성과 유지보수성을 높이기 위해 다음과 같은 표준 디렉토리 구조를 제안한다.

```
/
├── src/                # 메인 소스코드 (Arduino 스케치, .cpp, .h)
│   ├── App/
│   ├── Communicator/
│   └── ...
├── test/               # 테스트 관련 코드
│   ├── mocks/          # Mock 객체
│   ├── unit/           # 유닛 테스트
│   └── integration/    # 통합 테스트
├── docs/               # 문서 (본 보고서, 아키텍처 다이어그램 등)
├── lib/                # 외부 라이브러리 (필요시)
├── tools/              # 빌드, 배포 관련 스크립트
└── platformio.ini      # (권장) PlatformIO 설정 파일
```

-   **`src`**: 모든 애플리케이션 소스코드를 이곳으로 옮겨 역할의 구분을 명확히 한다.
-   **`test`**: 테스트 코드를 목적(unit, integration)에 따라 하위 폴더로 나누어 관리한다.
-   **`docs`**: 프로젝트와 관련된 모든 문서를 저장한다.
-   **`lib`**: DallasTemperature, OneWire 등 외부 라이브러리를 명시적으로 관리한다.
-   **(권장)** `platformio.ini`: Arduino IDE 대신 PlatformIO를 도입하면, 라이브러리 의존성 관리 및 빌드/테스트 환경 분리가 매우 용이해진다.

### 3.2. OOP 전환 및 의존성 역전 원칙(DIP) 적용
현재 구조에서 한 단계 더 나아가, 클래스 간의 결합도를 낮추고 유연성을 높이기 위해 **의존성 역전 원칙(Dependency Inversion Principle)** 적용을 제안한다.

1.  **추상 인터페이스(Abstract Base Class) 정의**: `ICommunicator`, `IDataProcessor` 와 같이 순수 가상 함수(pure virtual function)로만 이루어진 추상 클래스를 정의한다.
2.  **구체 클래스는 인터페이스에 의존**: `App`과 같은 상위 레벨 클래스는 `Communicator` 같은 구체 클래스가 아닌 `ICommunicator` 인터페이스에 의존하도록 코드를 수정한다.
3.  **의존성 주입(Dependency Injection)**: 실제 사용할 객체(e.g., `Communicator`, `MockCommunicator`)는 외부(e.g., `main.cpp` 또는 테스트 셋업)에서 생성하여 생성자나 초기화 함수를 통해 주입한다.

```cpp
// 예시: ICommunicator.h
class ICommunicator {
public:
    virtual ~ICommunicator() {}
    virtual void send(const char* message) = 0;
};

// 예시: App.h
class App {
private:
    ICommunicator& comm;
public:
    App(ICommunicator& communicator); // 생성자를 통한 의존성 주입
    void run();
};
```

### 3.3. 유닛 테스트 개선 및 의존성 분리
위와 같이 의존성 주입을 적용하면 테스트 환경 구축이 매우 간단해진다.

-   **테스트 대상**: `DataProcessor`
-   **테스트 방법**:
    1.  `DataProcessor`가 의존하는 `ICommunicator` 인터페이스에 대한 Mock 객체(`MockCommunicator`)를 만든다.
    2.  테스트 코드에서 `MockCommunicator` 객체를 생성한다.
    3.  `DataProcessor` 객체를 생성할 때 `MockCommunicator`를 주입한다.
    4.  `DataProcessor`의 함수를 실행하고, `MockCommunicator`의 함수가 예상대로 호출되었는지, 또는 특정 상태를 반환하는지 검증한다.

이렇게 하면 Arduino 프레임워크나 실제 하드웨어 없이, 순수 C++ 환경(PC)에서 빠르고 반복 가능한 테스트를 수행할 수 있다.

## 4. 실행 계획 (Action Plan)

1.  **1단계: 디렉토리 구조 변경**
    -   `src`, `docs`, `test` 폴더를 생성한다.
    -   기존 소스 파일들을 `src`로 이동시킨다.
    -   기존 테스트 파일들을 `test`로 이동시킨다.
    -   본 문서를 `docs`에 위치시킨다.
    -   빌드 시스템(Arduino IDE 또는 PlatformIO)이 새 구조를 인식하도록 설정을 수정한다.

2.  **2단계: 인터페이스 정의 및 리팩토링 (점진적)**
    -   가장 핵심적인 의존성(e.g., `Communicator`)부터 `ICommunicator` 인터페이스를 정의한다.
    -   `App` 클래스가 `ICommunicator`에 의존하도록 수정하고, 생성자에서 의존성을 주입받도록 변경한다.
    -   하나의 컴포넌트 변경이 완료될 때마다 컴파일 및 기존 테스트 통과 여부를 확인한다.

3.  **3단계: 독립적인 테스트 환경 구축**
    -   PlatformIO를 사용하거나, CMake/Makefile 스크립트를 작성하여 PC 환경에서 테스트를 빌드하고 실행할 수 있는 환경을 구축한다.
    -   이 테스트 빌드는 `src`의 일부 파일과 `test`의 Mock 객체만을 포함하여 Arduino 라이브러리와의 의존성을 제거한다.

4.  **4단계: 테스트 코드 리팩토링**
    -   기존 테스트를 새로운 독립 테스트 환경에서 실행되도록 수정한다.
    -   의존성 주입을 활용하여 순수 유닛 테스트를 보강한다.

## 5. 기대 효과
-   **유지보수성 향상**: 코드의 역할과 위치가 명확해져 수정 및 기능 추가가 용이해진다.
-   **테스트 신뢰성 및 속도 증가**: 하드웨어 독립적인 빠른 유닛 테스트가 가능해져 버그를 조기에 발견하고, 코드 변경에 대한 자신감을 얻을 수 있다.
-   **재사용성 및 확장성 증대**: 의존성이 낮은 모듈은 다른 프로젝트에서 재사용하기 쉽고, 새로운 기능을 추가할 때 기존 코드에 미치는 영향을 최소화할 수 있다.
-   **팀 협업 효율 증진**: 표준화된 구조는 새로운 팀원이 프로젝트에 적응하는 시간을 단축시킨다.
